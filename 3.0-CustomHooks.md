# Custom hooks for state

-  `useEffect()` for life cycle events
-  Aim for declarative style
   -  Instead of directly updating the UI, set state that controls UI behavior

## Async loading

-  Currently, `SpeakersList` uses an array and we search through it
-  Real world, it will be a database and things will be differently
-  Simulate delayed load by adding a delay

-  Add `useEffect()` in `SpeakersList` to set state (`useState([] as ISpeaker[])` and `setSpeakers(data)` in the `useEffect()` instead)
-  Add a `delay()` function and call it in `useEffect()`
   -  `useEffect()` isn't async, so wrap the code in an async function and call that function

```TypeScript
	useEffect(() => {
		const delayedAction = async () => {
			await delay(2000);
			setSpeakers(data);
		};
		delayedAction();
	});
```

Now UI draws, then speakers appear ~2 seconds later.

But there's a problem. `useEffect()` is being called every time the `SpeakerList` renders. Click on a favorite icon. Watch it change, then change back 2 seconds later when `useEffect()` sets the state back to the original value again.

`useEffect()` takes an array (2nd parameter) that tells it what must change to qualify for running the effect. You can [skip effects](https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects) that don't meet the conditions. Pass an empty array to never run after first run. (Now we don't lose favorite changes on the UI.)

### Loading indicator

What's a delay without a loading indicator? And what about errors (if the real world database dies)? So, we need to track:

-  Loading status
-  Error status (and message)

While loading, show a loading message.
If it errors, show an error message (`catch`).
Can `throw` an error on purpose to see the error behavior.

### Fallback renderer

A fallback renderer renders placeholder elements while your data is loading.

-  `npm install react-placeholder` and import it.
   -  https://www.npmjs.com/package/react-placeholder
-  Wrap the contents of the `container` `<div>` in `<ReactPlaceHolder>`
   -  Takes several attributes, but the important one is `ready` which defines the condition when the data is ready

But now I'm getting an error in the browser about an invalid hook call. Maybe because `react-placeholder` hasn't been updated for a year. Let's try `react-content-loader` which is more recent. I'm going to use one of the default loaders and worry about a custom loader later.

Okay, it's working in a way comparable to what he gets, so I'll fiddle with it later. Maybe switch to a simple spinner type loading indicator, given what I'm seeing.

**COMMIT: 3.0.1 - FEAT: use state to simulate async data loading**

## A custom hook for speaker data state

Components can get complex. Refactor state and life cycle management out of the component with a custom hook.

-  Hooks can contain other hooks
-  Custom hook = function that returns objects/variables

-  What data do we need to return?
   -  isLoadError
   -  loadErrorMessage
   -  isLoading
   -  speakers
   -  onFavoriteToggle()
-  He names the hook `useRequestSpeakers`, maybe looking ahead at a possible future load from an async source.

-  Create `src/hooks/useRequestSpeakers.ts`
-  Create hook function to accept `delayMs` and move code to it
-  Define interface for hook to return (five attributes above)
-  In the component, destructure the function result to get the values the component needs

**COMMIT: 3.0.2 - REFACTOR: move state and effect to a custom hook**

### Use status instead of booleans

When you have mutually exclusive boolean status flags, you create a possibility that you'll change one and not the other. The result could cause inconsistent behavior. So prefer proper status values i

How I approached it

-  In `useRequestSpeakers`, replace booleans `isLoading` and `isLoadError` with `componentStatus`
-  Define `type ComponentStatusType = 'LOADING' | 'LOADERROR' | 'READY';`
-  Initialize `componentStatus` to `'LOADING' as ComponentStatusType`
-  Set `componentStatus` appropriately in `useRequestSpeakers`
-  Change return for `useRequestSpeakers` (replace booleans with `componentStatus`)
-  In `SpeakersList`, change destructure to get `componentStatus`
-  `switch (componentStatus)` and return JSX for each state
-  `default:` returns a `<div>` reporting an unknown status
   -  `ComponentStatusType` should make it hard to return an unknown value, but covering the case is easy

What the instructor did differently

-  Differently named, but equivalent, status values as members of an object (because JS doesn't have types)
-  `export`s his object (not needed because TS type carries over automatically)
-  Doesn't use `switch`, just replaces conditions with comparisons to value instead of true

**COMMIT: 3.0.3 - REFACTOR: use a status value instead of booleans to avoid inconsistent status**

## Good practices notes

-  Choose named functions vs. nameless lambdas wisely
   -  Named functions for callbacks are often clearer
-  `async/await` syntax is usually easier to reason about than chained Promises (`.then/.catch/.finally`)
-  Prefer status values instead of boolean status flags
