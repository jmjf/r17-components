# Sharing data with context and `useContext()`

Shares data between a component and its descendants without passing props. It's like global data but scoped from the component where it's declared and lower. Toolbar controls in the example app are good cases for context.

## Use context to share theme info

In `SpeakersApp`, we create state for the theme and pass to `Speakers` and `Header`, plus use in `SpeakersApp`.

-  Create context instance with `createContext()` and export it so other components can import it to use.
-  Wrap parent component for context `<[context-name].Provider>`
-  Add data to the context by passing in `value` attribute
-  For TypeScript

   -  Declare an interface that represents data we'll put in the context
   -  `export const ExampleContext = createContext<IExampleContext>({} as IThemeContext);`
      -  Setting like this instead of `createContext<IExampleContext | null>(null);` avoids needing to cast as `IThemeContext` everywhere
   -  Then wrap JSX with something like`<ExampleContext.Provider value={{example, setExample}}>`

-  In `Header`, import the context and interface
-  `const { themeName } = useContext(ThemeContext);`
   -  When I tried `<IExampleContext | null>` version, I had to cast as `IThemeContext` here to avoid complaints that the context could be null.
-  A quick test shows the header works as expected; on to the toolbar
-  `useContext()` as above and destructure both `themeName` and `setThemeName`
-  Remove theme props from all declarations and uses in `Header`, `Speakers`, `SpeakersToolbar`, and `SpeakersApp`

Everything looks like it's working.

**COMMIT: 4.0.1 - REFACTOR: replace props for theme state sharing with context**

## Use a layout component for theme control

`SpeakersApp` has state/context management in addition to appearance. Let's move as much theme related stuff as we can to a new component.

-  Create a `Layout` component that handles theme context and state.
   -  Takes a prop `children`, which has type `JSX.Element`
      -  Standard/default prop that represents whatever is wrapped in `<Layout>`
   -  Also takes `startingTheme` and uses it to initialize state
   -  JSX wraps `{children}` in the theming `<div>`, which is wrapped in the `<ThemeContext.Provider>`
      -  Gives everything under `Layout` ability to use `ThemeContext`
   -  Declared `type ThemeType = 'light' | 'dark';` and used to encourage the value to be the right thing
      -  If I add another theme option in the dropdown, I need to add it to the type and logic that selects theme styles
-  In `SpeakersApp`
   -  Remove state and context
   -  Replace `ThemeContext` and theming `<div>` with `<Layout>` as a wrapper; `startingTheme="light"`
-  Everything that imports `ThemeContext` needs to get it from `Layout` now
   -  Affects `Headers` and `SpeakersToolbar`
   -  `SpeakersToolbar` uses `setThemeName`, so it needed to import `ThemeType` so it could cast to it

Now, theming is managed in `Layout` and `SpeakerApp`'s only connection to the theme is setting the initial theme.

-  Could hard code it in `Layout`, but I think this sets us up better to support the idea of a user profile with a preferred theme or detecting browser settings that might specify a preference.

In more complex applications, `Layout` may contain the header, footer, sidebars, and other base page structural components. If we had more than one page, it might make sense.

**COMMIT: 4.0.2 - REFACTOR: replace theming in SpeakersApp with a Layout component to simplify SpeakersApp (single responsibility)**
